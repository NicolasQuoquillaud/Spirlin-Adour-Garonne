---
title: "Spirlin dans le bassin Adour-Garonne"
subtitle: "Modélisation des impacts"
author: "OFB"
date: "`r format(Sys.time(), 'Le %d %B %Y')`"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Chargement des packages et des données

```{r}
library(tidyverse)
library(vegan)
library(tidyverse)
library(aspe)
library(flextable)
library(aspeQual)
library (stats)
library(AspeEEE)
```

On part des données prétraitées par le script précédent.

```{r}
load(file = "../processed_data/spirlin_dfs.RData")
```
# Préparation du tableau de données

Filtrage des taxons que l'on veut garder. On renomme les espèces que l'on veut rassembler. Ensuite un agrège pour ne plus avoir qu'un effectif par opération pour un code taxon.

```{r}
df_propre <- data %>%
  AspeEEE::recode_and_filter_species(sp_to_remove = c("OCL", "ASA", "ASL", "CRC", "PCC", "PFL", "HBG")) %>% 
  group_by_at(vars(-effectif)) %>% # group_by par toutes les variables sauf effectif
     summarise(effectif = sum(effectif, na.rm = TRUE), 
               .groups = "drop")
```

Passage de la table au format "large".

```{r}
data_indices <- df_propre %>% 
  pivot_wider(names_from = esp_code_alternatif,
              values_from = effectif,
              values_fill = 0)
```

Matrice des effectifs : on supprime les autres colonnes.

```{r}
matrice <- data_indices %>%
  select(-(sta_id:annee))
```

Calcul des indices :

```{r}
indices <- matrice %>% 
  transmute(richesse = specnumber(.),
            shannon = diversity(.),
            simpson = diversity(., index = "simpson"),
            pielou = shannon/log(richesse))
```

Ajout des indices au dataframe des donnée :

```{r}
data_indices <- data_indices %>%
  cbind(indices)
```

Identification des stations avec du spirlin (au moins sur une pêche) :

```{r}
sta_avec_spi <- data_indices %>%
  filter(SPI > 0) %>% 
  pull(sta_id) %>% 
  unique()
```

Sélection et enrichissement du tableau :

- Sélection des données sur les stations avec spirlin
- Codage d'une variable de présence / absence du spirlin
- Suppression des opérations sans valeur de l'IPR
- Ajout des métriques et des libellés des points / stations
- Sélection des variables d'intérêt


```{r}
model_data <- data_indices %>% 
  filter(sta_id %in% sta_avec_spi) %>% 
  mutate(spi = ifelse(SPI > 0,
                      "Présence",
                      "Absence")) %>% 
  select(sta_id,
         pop_id,
         pop_libelle,
         annee,
         spi,
         richesse,
         shannon,
         simpson,
         pielou) %>% 
  mutate(pop_id = as.factor(pop_id))

```

## Distribution des variables

Sans transformation :

```{r}
gg <- model_data %>% 
  pivot_longer(cols = c(richesse:pielou, annee),
               names_to = "Indices",
               values_to = "valeur") %>% 
  ggplot(aes(x = valeur)) +
    geom_histogram() +
    facet_wrap(~ Indices,
               scales = "free")

gg

```
Voyons si les distributions ont meilleurs mine après transformation log.

```{r}
gg + scale_x_log10()
```

Ce n'est pas mieux $\Rightarrow$ on ne transforme pas.

On transforme donc les métriques mais pas l'année où ça n'apporte rien.

## Modélisation

La fonction `lm_annee_spi()` du package `AspeEEE` permet de modéliser les indices en fonction de l'année et de la présence / absence du spirlin. Ici le modèle employé est linéaire, de la forme :

`indice ~ pop_id + annee + spi`


```{r}
indices <- model_data %>% 
  select(richesse:pielou) %>% 
  colnames()

indices
```

Ajustement des modèles. On précise `interaction = FALSE` car du fait de la colinéarité entre `annee` et `spi`, un terme d'interaction serait délicat à interpréter.

```{r}
model_data <- model_data %>% 
  filter(pielou > 0)

res <- lm_annee_spi(model_data = model_data,
                    metriques = indices,
                    interaction = FALSE)
```

Affichage. Le tableau est mis en forme avec les fonctions du package `flextable`. L'IPR est distingué par l'arrière-plan de couleur.


```{r}
res %>% 
  flextable() %>% 
  align(j = 2:4, align = "center", part = "all") %>% 
  set_table_properties(layout = "autofit", width = 1)
```

