---
title: "Spirlin dans le bassin Adour-Garonne"
subtitle: "Modélisation des impacts"
author: "OFB"
date: "`r format(Sys.time(), 'Le %d %B %Y')`"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Chargement des packages et des données

```{r}
library(tidyverse)
library(vegan)
library(tidyverse)
library(aspe)
library(flextable)
library(aspeQual)
library (stats)
```

On part des données prétraitées par le script précédent.

```{r}
load(file = "processed_data/spirlin_dfs.RData")
```
# Préparation du tableau de données

Passage de la table au format "large".

```{r}
data_indices <- data %>% 
  pivot_wider(names_from = esp_code_alternatif,
              values_from = effectif,
              values_fill = 0)
```

Matrice des effectifs.

```{r}
matrice <- data_indices %>%
  select(-(sta_id:annee))
```

Ici il faudra filtrer pour virer certains taxons.

Calcul des indices :

```{r}
indices <- matrice %>% 
  transmute(richesse = specnumber(.),
         shannon = diversity(.),
         simpson = diversity(., index = "simpson"),
         pielou = shannon/log(richesse))
```

Ajout des indices au dataframe des donnée :

```{r}
data_indices <- data_indices %>%
  cbind(indices)
```

Identification des stations avec du spirlin :

```{r}
sta_avec_spi <- data_indices %>%
  filter(SPI > 0) %>% 
  pull(sta_id) %>% 
  unique()
```

Sélection et enrichissement du tableau :

- Sélection des données sur les stations avec spirlin
- Codage d'une variable de présence / absence du spirlin
- Suppression des opérations sans valeur de l'IPR
- Ajout des métriques et des libellés des points / stations
- Sélection des variables d'intérêt


```{r}
mode_data <- data_indices %>% 
  filter(sta_id %in% sta_avec_spi) %>% 
  mutate(spi = ifelse(SPI > 0,
                      "Présence",
                      "Absence")) %>% 
  select(sta_id,
         pop_id,
         pop_libelle,
         annee,
         spi,
         richesse,
         shannon,
         simpson,
         pielou) %>% 
  mutate(pop_id = as.factor(pop_id))

```
## Distribution des variables

Sans transformation :

```{r}
gg <- mode_data %>% 
  pivot_longer(cols = c(richesse:pielou, annee),
               names_to = "Indices",
               values_to = "valeur") %>% 
  ggplot(aes(x = valeur)) +
    geom_histogram() +
    facet_wrap(~ Indices,
               scales = "free")

gg

```
Certaines métriques sont distribuées de manière très asymétrique (en particulier `dii`), donc on essaye une transformation log :

```{r}
gg + scale_x_log10()
```

>Les distributions sont plus proches de distributions en cloche après transformations log.

On transforme donc les métriques mais pas l'année où ça n'apporte rien.

```{r}
mode_data <- mode_data %>%
  mutate(across(richesse:pielou, ~ log(.)))
```

## Construction des outils


Création d'une fonction qui renvoie les résultats du modèle pour une métrique (ou sur l'IPR, ou sur n'importe quoi du genre). Ici, le modèle employé est linéaire, de la forme :

`métrique ~ pop_id + annee * spi`

On recherche donc les effets indépendants des stations, de l'année, de la présence du spirlin, et du terme d'interaction `spi x annee` pour détecter si les pentes temporelles diffèrent en présence et en absence de spirlin. 
 
```{r}
lm_1_indice <- function(model_data, Indice, interaction = TRUE) {
  
  # construction de la formule en fonction de la variable dépendante
  if (interaction) {
    fm <- as.formula(paste0(Indice,
                            " ~ pop_id + annee * spi"))
  } else {
    fm <- as.formula(paste0(Indice,
                            " ~ pop_id + annee + spi"))
}

  # on cale le modèle
  mod <- lm(formula = fm, 
            data = model_data)
  
  dist_cook <- cooks.distance(mod)
  seuil_cook <- 4 / nrow(model_data)
  model_data <- model_data %>% 
    cbind(dist_cook) %>% # ajout de la colonne avec les distances
    filter(dist_cook < seuil_cook) # suppression des observations avec distance > 4/N
  
  mod <- lm(formula = fm, 
            data = model_data)

  # récupération de ce qui ous intéresse dans les résultats et mise en forme
    if (interaction) {
  resultat <-
    summary(mod)$coefficients[c("(Intercept)", "annee", "spiPrésence", "annee:spiPrésence"), ]
    } else {
    resultat <-
    summary(mod)$coefficients[c("(Intercept)", "annee", "spiPrésence"), ]
    }
    
  resultat <-resultat %>%   
    as.data.frame() %>%
    select(coef = Estimate,
           pval = `Pr(>|t|)`) %>%
    mutate(
      sig = case_when(
        pval > 0.05 ~ "NS",
        pval <= 0.05 & pval > 0.01 ~ "*",
        pval <= 0.01 & pval > 0.001 ~ "**",
        TRUE ~ "***"
      )
    ) %>%
    mutate(text = paste0(round(coef, 3),
                         " (",
                         sig,
                         ")"
    )) %>%
    select(text) %>%
    t()
  
  # on nomme la ligne d'après le nom de la métrique
  row.names(resultat) <- Indice
  tableau <- data.frame(residus = mod$residuals)

  # sortie
  ggplot(data = tableau, aes(x = residus)) + geom_histogram(aes(y = ..density..), alpha = 0.5) + 
    geom_density(alpha = 0.5) +
    geom_vline(aes(xintercept=mean(residus, na.rm=T)), color="red", linetype="dashed", size=1) + 
    ggtitle("Histogramme du logarythme de richesse")
  resultat
}
```


Essai sur la richesse

```{r}
lm_1_indice(model_data = mode_data,
              Indice = "richesse",
              interaction = FALSE)
```

## Application

Vecteur contenant les noms des métriques à modéliser (à partir des noms des colonnes entre richesse et simpson).

```{r}
mes_indices <- mode_data %>% 
  select(richesse:pielou) %>% 
  colnames()

mes_indices
```

Modélisation sur l'ensemble.

La fonction `map()` permet d'appliquer la fonction non pas à un indice, mais à l'ensemble de indices du vecteur `mes_indices`. Elle retourne une liste de `dataframes` (un par indice). Ces dataframes sont ensuite empilés et on récupère les noms des lignes dans une colonne puis on renomme certaines colonnes. 

```{r}
res_interraction <- map(.x = mes_indices,
                      .f = lm_1_indice,
                      model_data = mode_data) %>% 
  reduce(rbind) %>% 
  as.data.frame() %>% 
  rownames_to_column() %>% 
  rename(Intercept = `(Intercept)`,
         Indice = rowname,
         Année = annee)

sans_interraction <- map(.x = mes_indices,
                      .f = lm_1_indice,
                      model_data = mode_data,
                      interaction = FALSE) %>% 
  reduce(rbind) %>% 
  as.data.frame() %>% 
  rownames_to_column() %>% 
  rename(Intercept = `(Intercept)`,
         Indice = rowname,
         Année = annee)
```

Affichage. Le tableau est mis en forme avec les fonctions du package `flextable`. L'IPR est distingué par l'arrière-plan de couleur.

Sans interaction `annee:spiPrésence` :

```{r}
sans_interract %>% 
  flextable() %>% 
  align(j = 2:4, align = "center", part = "all") %>% 
  set_table_properties(layout = "autofit", width = 1) %>% 
  bg(i = 1, bg = "lightgreen")
```