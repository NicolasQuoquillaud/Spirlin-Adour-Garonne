---
title: "Spirlin dans le bassin Adour-Garonne"
subtitle: "Modélisation"
author: "OFB"
date: "`r format(Sys.time(), 'Le %d %B %Y')`"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Chargement des packages et des données
# devtools::install_github("pascalirz/aspeQual")
```{r}
library(tidyverse)
library(aspe)
library(flextable)
library(aspeQual)
library (stats)
```


# Impact du spirlin sur l'IPR

## Préparation du tableau de données

On part des données prétraitées par le script précédent.

```{r}
load(file = "processed_data/spirlin_dfs.RData")
```

Identifiants des stations avec du spirlin :

```{r}
sta_avec_spi <- ope_data %>% 
  filter(eff_spi > 0) %>% 
  pull(sta_id) %>% 
  unique()
```

Sélection et enrichissement du tableau :

- Sélection des données sur les stations avec spirlin
- Codage d'une variable de présence / absence du spirlin
- Suppression des opérations sans valeur de l'IPR
- Ajout des métriques et des libellés des points / stations
- Sélection des variables d'intérêt


```{r}
mod_data <- ope_data %>% 
  filter(sta_id %in% sta_avec_spi) %>% 
  mutate(spi = ifelse(eff_spi > 0,
                      "Présence",
                      "Absence")) %>% 
  mef_ajouter_ipr() %>% 
  filter(!is.na(ipr)) %>% 
  mef_ajouter_metriques() %>% 
  mef_ajouter_libelle() %>% 
  select(sta_id,
         pop_id,
         pop_libelle,
         annee,
         spi,
         ipr,
         ner:dti) %>% 
  mutate(pop_id = as.factor(pop_id))

```

## Distribution des variables

Sans transformation :

```{r}
gg <- mod_data %>% 
  pivot_longer(cols = c(ipr:dti, annee),
               names_to = "metrique",
               values_to = "valeur") %>% 
  ggplot(aes(x = valeur)) +
    geom_histogram() +
    facet_wrap(~ metrique,
               scales = "free")

gg

```

Certaines métriques sont distribuées de manière très asymétrique (en particulier `dii`), donc on essaye une transformation log :

```{r}
gg + scale_x_log10()
```

>Les distributions sont plus proches de distributions en cloche après transformations log.

On transforme donc les métriques mais pas l'année où ça n'apporte rien.

```{r}
mod_data <- mod_data %>%
  mutate(across(ipr:dti, ~ sqrt(.)))
```



## Construction des outils


Création d'une fonction qui renvoie les résultats du modèle pour une métrique (ou sur l'IPR, ou sur n'importe quoi du genre). Ici, le modèle employé est linéaire, de la forme :

`métrique ~ pop_id + annee * spi`

On recherche donc les effets indépendants des stations, de l'année, de la présence du spirlin, et du terme d'interaction `spi x annee` pour détecter si les pentes temporelles diffèrent en présence et en absence de spirlin. 
 
```{r}
lm_1_metrique <- function(model_data, metrique, interaction = TRUE) {
  
  # construction de la formule en fonction de la variable dépendante
  if (interaction) {
    fm <- as.formula(paste0(metrique,
                            " ~ pop_id + annee * spi"))
  } else {
    fm <- as.formula(paste0(metrique,
                            " ~ pop_id + annee + spi"))
}

  # on cale le modèle
  mod <- lm(formula = fm, 
            data = model_data)
  
  dist_cook <- cooks.distance(mod)
  seuil_cook <- 4 / nrow(model_data)
  model_data <- model_data %>% 
    cbind(dist_cook) %>% # ajout de la colonne avec les distances
    filter(dist_cook < seuil_cook) # suppression des observations avec distance > 4/N
  
  mod <- lm(formula = fm, 
            data = model_data)

  # récupération de ce qui ous intéresse dans les résultats et mise en forme
    if (interaction) {
  resultat <-
    summary(mod)$coefficients[c("(Intercept)", "annee", "spiPrésence", "annee:spiPrésence"), ]
    } else {
    resultat <-
    summary(mod)$coefficients[c("(Intercept)", "annee", "spiPrésence"), ]
    }
    
  resultat <-resultat %>%   
    as.data.frame() %>%
    select(coef = Estimate,
           pval = `Pr(>|t|)`) %>%
    mutate(
      sig = case_when(
        pval > 0.05 ~ "NS",
        pval <= 0.05 & pval > 0.01 ~ "*",
        pval <= 0.01 & pval > 0.001 ~ "**",
        TRUE ~ "***"
      )
    ) %>%
    mutate(text = paste0(round(coef, 3),
                         " (",
                         sig,
                         ")"
    )) %>%
    select(text) %>%
    t()
  
  # on nomme la ligne d'après le nom de la métrique
  row.names(resultat) <- metrique
  tableau <- data.frame(residus = mod$residuals)

  # sortie
  resultat
  ggplot(data = tableau, aes(x = residus)) + geom_histogram(aes(y = ..density..), alpha = 0.5) + 
    geom_density(alpha = 0.5) +
    geom_vline(aes(xintercept=mean(residus, na.rm=T)), color="red", linetype="dashed", size=1)
}
```

Essai sur l'IPR

```{r}
lm_1_metrique(model_data = mod_data,
              metrique = "ipr",
              interaction = FALSE)
```

## Application

Vecteur contenant les noms des métriques à modéliser (à partir des noms des colonnes entre ipr et dti).

```{r}
mes_metriques <- mod_data %>% 
  select(ipr:dti) %>% 
  colnames()

mes_metriques
```

Modélisation sur l'ensemble.

La fonction `map()` permet d'appliquer la fonction non pas à une métrique, mais à l'ensemble de métriques du vecteur `mes_metriques`. Elle retourne une liste de `dataframes` (un par métrique). Ces dataframes sont ensuite empilés et on récupère les noms des lignes dans une colonne puis on renomme certaines colonnes. 

```{r}
res_avec_inter <- map(.x = mes_metriques,
                      .f = lm_1_metrique,
                      model_data = mod_data) %>% 
  reduce(rbind) %>% 
  as.data.frame() %>% 
  rownames_to_column() %>% 
  rename(Intercept = `(Intercept)`,
         Métrique = rowname,
         Année = annee)

res_sans_inter <- map(.x = mes_metriques,
                      .f = lm_1_metrique,
                      model_data = mod_data,
                      interaction = FALSE) %>% 
  reduce(rbind) %>% 
  as.data.frame() %>% 
  rownames_to_column() %>% 
  rename(Intercept = `(Intercept)`,
         Métrique = rowname,
         Année = annee)
```

Affichage. Le tableau est mis en forme avec les fonctions du package `flextable`. L'IPR est distingué par l'arrière-plan de couleur.

Sans interaction `annee:spiPrésence` :

```{r}
res_sans_inter %>% 
  flextable() %>% 
  align(j = 2:4, align = "center", part = "all") %>% 
  set_table_properties(layout = "autofit", width = 1) %>% 
  bg(i = 1, bg = "lightgreen")
```

Avec interaction `annee:spiPrésence` :

```{r}
res_avec_inter %>% 
  flextable() %>% 
  align(j = 2:5, align = "center", part = "all") %>% 
  set_table_properties(layout = "autofit", width = 1) %>% 
  bg(i = 1, bg = "lightgreen")
```

## Interprétation

Une ligne représente une métrique. On voit, pour chacune des variables explicatives, le coefficient associé, et entre parenthèses le niveau de significativité :

- (NS) non significatif au seuil de 5%
- (*) p < 5%
- (**) p < 1%
- (***) p < 0.1%

On entend par significativité le fait d'être significativement différent de zéro.

L'intercept du modèle est sa constante. C'est la valeur que prendrait la métrique (ici en fait le log de la métrique) en l'an zéro en l'absence de spirlin.

**Exemple sur le tableau sans interaction :**

Pour la métrique `ner`, on a un effet `année` significatif avec un coefficient de `r res_sans_inter %>% filter(Métrique == "ner") %>% pull(Année) %>% str_replace(" \\s*\\([^\\)]+\\)", "")`. Ce coefficient est positif $\Rightarrow$ la métrique augmente au fil du temps, en moyenne sur l'ensemble des stations. L'effet de la présence du spirlin (`spiPrésence`) est significatif avec un coefficient de `r res_sans_inter %>% filter(Métrique == "ner") %>% pull(spiPrésence)`. Les valeurs du log de la métriques, quelle que soit l'année, sont donc inférieures de `r res_sans_inter %>% filter(Métrique == "ner") %>% pull(spiPrésence) %>% str_replace(" \\s*\\([^\\)]+\\)", "")` en présence du spirlin par rapport à son absence.


**Exemple sur le tableau avec interaction :**

Pour la métrique `dit`, on a un effet `année` significatif avec un coefficient de `r res_avec_inter %>% filter(Métrique == "dit") %>% pull(Année)`. Ce coefficient est négatif $\Rightarrow$ la métrique diminue au fil du temps, en moyenne sur l'ensemble des stations. L'effet de la présence du spirlin (`spiPrésence`) n'est pas significatif au seuil de 5%, pas plus que le terme d'interaction `annee:spiPrésence`.

Pour la métrique `dii`, on n'a pas d'effet `année` significatif $\Rightarrow$ la situation est stable au fil du temps, en moyenne sur l'ensemble des stations. L'effet de la présence du spirlin (`spiPrésence`) est significatif avec un coefficient de `r res_avec_inter %>% filter(Métrique == "dii") %>% pull(spiPrésence) %>% str_replace(" \\s*\\([^\\)]+\\)", "")`. La métrique est donc plus élevée en présence de spirlin en l'an zéro. Le terme d'interaction `annee:spiPrésence` est significatif avec un coefficient de `r res_avec_inter %>% filter(Métrique == "dii") %>% pull("annee:spiPrésence")` donc en présence de spirlin, la métrique diminue au fil du temps.




